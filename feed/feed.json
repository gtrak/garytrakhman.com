{
  "version": "https://jsonfeed.org/version/1",
  "title": "Gary Trakhman&#39;s tech blog",
  "home_page_url": "https://blog.garytrakhman.com/",
  "feed_url": "https://blog.garytrakhman.com/feed/feed.json",
  "description": "Longer than a tweet",
  "author": {
    "name": "Gary Trakhman",
    "url": "https://blog.garytrakhman.com/about"
  },
  "items": [{
      "id": "https://blog.garytrakhman.com/posts/2022-05-07-fp-tipping-point/",
      "url": "https://blog.garytrakhman.com/posts/2022-05-07-fp-tipping-point/",
      "title": "The Functional Programming Tipping Point",
      "content_html": "<p>or, why I'm just not that into Clojure going forward.</p>\n<p>Functional programming had an interesting allure to me. I started\noff my serious programming by learning C and C++, then quickly found\nthem to be onerous and full of pitfalls. I reached for Python (2.5) as an\nalternative and found I could try stuff out much more quickly, but it was\nalso just very messy once your program got large.</p>\n<p>I resolved to <em>really learn</em> 'Object-Oriented Programming' by reading 'Design Patterns'\nand other resources I could find, but to be honest, it seemed like a lot of work for\nlittle benefit. I thought there were 2 possibilities, either OOP was complete trash,\nor maybe I just wasn't smart enough. I suspected that the real truth was we were working around\nlanguage limitations without revisiting the underlying assumptions.</p>\n<p>Eventually, I came across <a href=\"https://norvig.com/design-patterns/\">Peter Norvig's great presentation</a>\non how design patterns present themselves in dynamic languages, and it suddenly all made sense.\nI had an existence proof that you can just stop repeating yourself so much if you use a different\nlanguage. The presentation suggests lisp, but I didn't see Common Lisp or Scheme to be feasible for\nmy job prospects. Python was fine, but I was feeling some friction with the GIL and it was a worse fit\nfor the J2EE work I was doing early in my career. The timing lined up with Clojure gaining traction,\nso I resolved to learn more about it and get a chance to work with it.</p>\n<p>I then spent a few years as a satisfied clojure enthusiast, I really loved the power the\nlanguage provided and felt like I could really do anything with it. I did work on a few very interesting\nproblems early on, and they just couldn't have gotten done in Java. I saw the value of using all the\nfeatures Clojure provided in certain contexts. It seemed like a no-brainer to continue down that path,\nso I did. Some forces conspired to change my opinion, though.</p>\n<ul>\n<li>My particular local tech job market was relatively small. It was tough to attempt to\nintroduce Clojure at companies that didn't already use it. It's not 'just a jar'. I enjoyed\nworking on a team more than being the solo clojure expert. Even when one company formally decided to adopt\nClojure, too many other issues prevented it from being effective.</li>\n<li>Other languages got better. In particular, we saw the rise and fall of many experiments, some of\nwhich are still in use and some which became dead ends.\n<ul>\n<li>CoffeeScript: used it, rewrote all we had to ES6 once that landed.</li>\n<li>Elixir: looked like it took a lot of developers from Ruby, but I didn't use it.</li>\n<li>Elm, Purescript, ReasonML: showed there was some pent-up demand for applying FP principles on the\nfrontend, but didn't catch on.</li>\n<li>Rust: Not really FP, but it had some interesting ideas and took some of the audience. Companies\nthat scaled up on scripting languages are rewriting core parts in Rust for performance.</li>\n<li>Ocaml: used it professionally. I like the language, but it was frustrating experience. It got\nsome more attention due to ReasonML. I'll write what I like and don't like about it in more detail separately.</li>\n</ul>\n</li>\n<li>Node.js grow from a niche use-case to being a mainstream language.</li>\n<li>Microsoft changed the game with VSCode, .NET Core on Linux/Mac, and Typescript.\n<ul>\n<li>Flow deserves honorable mention, but I think Typescript won.</li>\n<li>VSCode and LSP have dominated the IDE scene. I still use Emacs where it's more convenient,\nbut I have been using VSCode for javascript, python, and C# and am quite happy with it.</li>\n</ul>\n</li>\n</ul>\n<p>While all this was happening, Clojure barely changed at all. Other people have written much\naround issues in the Clojure community. Personally, I found it frustrating to have no roadmap and\nno idea what the future holds. There were a lot of early decisions that made sense in 2008, but\nwould have gone differently if it were rewritten today. I really now prefer for Clojure to have been a\ncommunity project with clear process and community governance. It's not enough to commit to no breaking\nchanges and only do incremental improvements.</p>\n<p>At this rate, Clojure is long in the tooth. Type systems are actually worth it, and a language very\nsimilar to Clojure could be made with one. Would that be better? Can you definitively say that it\nwouldn't be better, all other things the same? In general I feel there is too much post-hoc rationalization of\nprior decisions. Writing a language and leading a language's growth sounds hard, and I haven't done it,\nbut I don't think other communities spend as much effort justifying past decisions so much.</p>\n<p>Having attempted to teach Clojure to others a few times, it's tiring to constantly apologize\nfor its warts, and the gap between other languages is thinning especially for more common\nuse-cases. It used to be the case that there was a clear payoff after the initial learning hump, but\nnow it's less obvious since fewer people are coming from Java.</p>\n<p>I now find myself in the surprising position where I am doing my prototyping in Clojure or\nOcaml, but consider Javascript(Typescript) to be more suitable for production. I didn't expect\nto end up here.</p>\n",
      "date_published": "2022-05-07T00:00:00Z"
    },{
      "id": "https://blog.garytrakhman.com/posts/2022-05-07-firstpost/",
      "url": "https://blog.garytrakhman.com/posts/2022-05-07-firstpost/",
      "title": "New blog",
      "content_html": "<p>I've been meaning to blog again after a long hiatus. Early in my\ndevelopment career it was trendy to do so, but in the 2020s there\nare just too many blogs out there.</p>\n<p>This one will host some technical opinions relevant to what I am working\non, and I will strive to not repeat what is available elsewhere. I will\nalso not provide tutorials, but I expect might have particular crevices\nof technologies to explore and show to others.</p>\n<p>Twitter largely replaced blogging and reading blogs for me over the last\nfew years. Unfortunately, while it is a nice way to find content and\nkeep up with people, it also promotes distracted thought. I think most can\nagree that when writing larger blocks of text, you can more easily\nclarify each thought and test it against your other thoughts to see\nif makes sense. With the smaller Twitter format, it seems like I'm\nsusceptible to interruption by likely distracted people posting in real-time.\nI need the the bar to be a little higher.</p>\n<p>So, when I ask myself what's the purpose of this blog, I think it's to\nremove those distractions from my own thought process and to rebuild\nmy own reading and writing habits.</p>\n",
      "date_published": "2022-05-07T00:00:00Z"
    }
  ]
}
